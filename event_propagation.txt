Когда происходит событие мы его распространяем по дочерним элементам. Но если элемент, к примеру, деактивирован, то идти вглубь (trickle down) нет смысла.

Иногда мы хотим, чтобы событие безусловно дошло до всех. Например draw. Потому как должны отрисоваться все элементы.

Когда событие доходит до своей цели, то распространение заканчивается. Возьмём пример, когда событие дошло до деактивированного элемента, то этот элемент прекращает распространение (аля захватывает, capture event) и становится целью (target). Во время всплытия родительские элементы будут видеть куда "попало" событие.

После захвата начинается всплытие (bubling up). Во время всплытия родительские элементы могут по разному реагировать в зависимости от того какой дочерний элемент обработал событие

Главное отличие фазы capturing VS bubling:

    во время capturing цель ещё не известна
    во время bubling мы знаем, кто обработал событие


JavaScript в своём арсенале имеет функцию, которая останавливает всплытие. Это "полезно", т.к. если родитель и дочерний элемент реагируют на click по разному, то мы можем предотвратить событие у родителя.
Например если реакция на клик запрограммирована так, что уничтожает элемент.

    При клике на родителе он будет уничтожен. Соответсвенно он уничтожит всех своих детей тоже.
    Тут всё ОК.

    Но если мы кликаем на ребёнке, то он тоже уничтожается.
    Тут тоже всё ОК.

    НО! Событие всплывёт и click произойдёт на родителе тоже. Соответственно он уничтожится.
    Это не желаемый результат.

Поэтому придумали остановку всплытия.

На мой взгляд проблема кроется в том, что родитель запрограммирован неверно. Если нам необходимо, чтобы родитель не уничтожался при click на детях, то родитель должен реагировать на событие только тогда, когда click происходит **именно на родителе**: target == parent.

ВЫВОД: Если правильно программировать родителя, то лишние функции будут не нужны.

Итого у нас есть 3 точки для реакции на событие:
capture_event - когда событие возникло и видимо для родителя
on_event      - когда событие поцелило элемент и он должен обработать его
buble_event   - информация о том, что событие обработано элементом

on_event должен происходить после buble_event, т.к. на фазе всплытия родитель может решить, что не хочет, чтобы данная цель как-то реагировала на неё, и сбросить свойство target.

Иногда может показаться, что остановка распространения события оправдана. Т.к. может быть ситуация, когда заведомо известно, что более никто на распространие события не отреагирует. Возможно это и так. Но нет никакой гарантии, что в будущем не появятся объекты, которые будут хотеть реагировать на это событие.
